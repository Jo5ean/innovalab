---
interface Props {
	image?: string;
}

const { description, image: imageConfig } = config;
const {  image = imageConfig } = Astro.props;

import config from "@/config/config";
import Header from "./partials/Header.astro";

const { pathname } = Astro.url;
const url = Astro.url.toString().replace("http://", "https://");
const canonicalURL = new URL(pathname, url);
---

<!doctype html>
<html lang="es" class="scroll-smooth">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width" />
		<link rel="icon" type="image/x-icon" href="/favicon.ico" />
		<meta name="generator" content={Astro.generator} />
		<link
			rel="stylesheet"
			href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css"
		/>
		<title>{config.title}</title>

		<meta charset="UTF-8" />
		<meta name="description" content={description} />
		<link rel="canonical" href={canonicalURL} />
		<meta
			name="viewport"
			content="width=device-width,initial-scale=1,shrink-to-fit=no"
		/>
		<meta http-equiv="x-ua-compatible" content="ie=edge" />

		<meta name="theme-color" content={config.theme_color} />
		<meta name="keywords" content={config.keywords} />
		<meta name="twitter:card" content="summary_large_image" />
		<meta name="twitter:site" content={config.author} />
		<meta name="twitter:creator" content={config.author} />
		<meta name="twitter:title" content={config.title} />
		<meta name="twitter:description" content={description} />
		<meta name="twitter:image" content={new URL(image, url)} />

		<meta name="og:image" content={new URL(image, url)} />
		<meta name="og:title" content={config.title} />
		<meta name="og:description" content={description} />
		<meta name="og:url" content={url} />
		<meta name="og:site_name" content={config.site_name} />
		<meta name="og:type" content="website" />
		<meta name="og:locale" content="es_ES" />

		<meta itemprop="image" content={new URL(image, url)} />

		<meta name="robots" content="index, follow" />
		<meta name="googlebot" content="index, follow" />

		<meta name="msapplication-config" content="/browserconfig.xml" />

		<link rel="manifest" href="/manifest.webmanifest" />

		<link rel="preconnect" href="https://fonts.googleapis.com" />
		<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
		<link
			href="https://fonts.googleapis.com/css2?family=Montserrat:ital,wght@0,100..900;1,100..900&family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&display=swap"
			rel="stylesheet"
		/>
		{config.IS_PRODUCTION && <></>}
		<style is:global>
			/* Animación para letras individuales */
			.split-text .char {
				display: inline-block;
				opacity: 0;
				transform: translateY(30px);
				transition: opacity 0.3s ease, transform 0.3s ease;
			}
			
			.split-text .char.visible {
				opacity: 1;
				transform: translateY(0);
			}
			
			/* Animación para contenedores */
			.fade-in {
				opacity: 0;
				transform: translateY(20px);
				transition: opacity 0.6s ease, transform 0.6s ease;
			}
			
			.fade-in.visible {
				opacity: 1;
				transform: translateY(0);
			}
			
			/* Estilo para ocultar los valores originales mientras se animan */
			.count-number-original {
				display: none;
			}
		</style>
	</head>
	<body class="max-w-full overflow-x-hidden font-body">
		<Header />
		<main class="flex flex-col items-stretch justify-between">
			<slot />
		</main>
		<script>
			let currentSection = 0;
			function isMobile() {
				return window.innerWidth < 1024;
			}
			const sections = document.querySelectorAll('section') as NodeListOf<HTMLElement>;
			
			const updateSection = () => {
				if (!isMobile()) {
					let isScrolling = false;
					currentSection=0;
					sections[0].scrollIntoView({ behavior: 'smooth' });

					function scrollToSection(index:number) {
						if (isScrolling) return;
						isScrolling = true;
						currentSection = index;
						if(!sections[index]) return;
						sections[index].scrollIntoView({ behavior: 'smooth' });
						setTimeout(() => {
							isScrolling = false;
						}, 500);
					}

					window.addEventListener('wheel', (e) => {
						e.preventDefault();
						if (isScrolling) return;

						const delta = e.deltaY;
						const direction = delta > 0 ? 1 : -1;

						if ((direction > 0 && currentSection < sections.length - 1) || (direction < 0 && currentSection > 0)) {
							scrollToSection(currentSection + direction);
						}
					}, { passive: false });
				}
			}
			document.addEventListener('DOMContentLoaded', () => {
				updateSection();
					
				window.addEventListener('resize', () => {
					updateSection();
				});
			});
		</script>
		<script is:inline src="https://unpkg.com/split-type"></script>
		<script is:inline>
			document.addEventListener('DOMContentLoaded', () => {
				// Configurar animación de texto letra por letra
				document.querySelectorAll('.split-text').forEach(element => {
					new SplitType(element, { types: 'chars' });
				});
				
				// Crear observer para animar elementos al verlos
				const observer = new IntersectionObserver(entries => {
					entries.forEach(entry => {
						if (entry.isIntersecting) {
							// Si es un título con animación letra por letra
							if (entry.target.classList.contains('split-text')) {
								const chars = entry.target.querySelectorAll('.char');
								chars.forEach((char, index) => {
									setTimeout(() => {
										char.classList.add('visible');
									}, 30 * index);
								});
							} 
							// Si es un contenedor con fade
							else if (entry.target.classList.contains('fade-in')) {
								entry.target.classList.add('visible');
							}
							
							// Dejar de observar después de animar
							observer.unobserve(entry.target);
						}
					});
				}, {
					threshold: 0.2
				});
				
				// Observar todos los elementos que necesitan animación
				document.querySelectorAll('.split-text, .fade-in').forEach(el => {
					observer.observe(el);
				});
			});
		</script>
		<script is:inline>
			// Función para animar contadores numéricos
			function animateCounters() {
				const counterElements = document.querySelectorAll('.counter-value');
				
				counterElements.forEach(el => {
					// Obtener el texto original
					const originalText = el.textContent;
					
					// Extraer prefijo (caracteres no numéricos al inicio)
					let prefixMatch = originalText.match(/^[^\d]*/);
					let prefix = prefixMatch ? prefixMatch[0] : '';
					
					// Obtener la parte numérica y el sufijo
					let valueWithSuffix = originalText.substring(prefix.length);
					let suffixMatch = valueWithSuffix.match(/[^\d.,]+$/);
					let suffix = suffixMatch ? suffixMatch[0] : '';
					
					// Obtener solo el número limpio
					let cleanNumber = valueWithSuffix.replace(suffix, '').replace(/,/g, '');
					let targetNumber = parseFloat(cleanNumber);
					
					// Crear una copia para la animación
					const originalSpan = document.createElement('span');
					originalSpan.className = 'count-number-original';
					originalSpan.style.display = 'none';
					originalSpan.textContent = originalText;
					
					const animatedSpan = document.createElement('span');
					animatedSpan.className = 'count-number-animated';
					
					// Reemplazar el contenido
					el.textContent = '';
					el.appendChild(originalSpan);
					el.appendChild(animatedSpan);
					
					// Crear observador
					const observer = new IntersectionObserver((entries) => {
						if (entries[0].isIntersecting) {
							let currentNumber = 0;
							const duration = 2000;
							const steps = 60;
							const increment = targetNumber / steps;
							const interval = duration / steps;
							
							function count() {
								currentNumber += increment;
								if (currentNumber >= targetNumber) {
									el.textContent = originalText; // Restaurar texto original al finalizar
									return;
								}
								
								// Formatear número
								let formattedNumber;
								if (targetNumber > 999) {
									formattedNumber = Math.floor(currentNumber).toLocaleString();
								} else {
									formattedNumber = Math.floor(currentNumber);
								}
								
								// Combinar todo correctamente
								animatedSpan.textContent = prefix + formattedNumber + suffix;
								setTimeout(count, interval);
							}
							
							// Iniciar conteo
							count();
							observer.disconnect();
						}
					}, { threshold: 0.2 });
					
					observer.observe(el);
				});
			}
			
			// Ejecutar cuando el DOM esté listo
			document.addEventListener('DOMContentLoaded', () => {
				// ... código existente ...
				animateCounters();
			});
		</script>
		<script is:inline>
			// Animación de contadores de manera no invasiva
			const counterSection = document.querySelector('section:has(b[class*="font-extrabold"])');
			if (counterSection) {
				const numberElements = counterSection.querySelectorAll('b[class*="font-extrabold"]');
				
				// Crear observador
				const observer = new IntersectionObserver((entries) => {
					if (entries[0].isIntersecting) {
						// Animar cada número
						numberElements.forEach(el => {
							// Guardar texto original
							const originalText = el.textContent;
							
							// Extraer el número y separar prefijo/sufijo
							let prefixMatch = originalText.match(/^[^\d]*/);
							let prefix = prefixMatch ? prefixMatch[0] : '';
							
							let numberStr = originalText.replace(prefix, '');
							let suffixMatch = numberStr.match(/[^\d.,]+$/);
							let suffix = suffixMatch ? suffixMatch[0] : '';
							
							// Obtener solo el número limpio
							let cleanNumber = numberStr.replace(suffix, '').replace(/,/g, '');
							let targetNumber = parseFloat(cleanNumber);
							
							// Valores para la animación
							let currentNumber = 0;
							const duration = 2000;
							const steps = 60;
							const increment = targetNumber / steps;
							const interval = duration / steps;
							
							// Función de conteo
							function count() {
								currentNumber += increment;
								if (currentNumber >= targetNumber) {
									el.textContent = originalText; // Restaurar texto original al finalizar
									return;
								}
								
								// Formatear número
								let formattedNumber;
								if (targetNumber > 999) {
									formattedNumber = Math.floor(currentNumber).toLocaleString();
								} else {
									formattedNumber = Math.floor(currentNumber);
								}
								
								// Combinar prefijo, número formateado y sufijo
								el.textContent = prefix + formattedNumber + suffix;
								setTimeout(count, interval);
							}
							
							// Iniciar conteo
							count();
						});
						
						observer.disconnect();
					}
				}, { threshold: 0.2 });
				
				observer.observe(counterSection);
			}
		</script>
	</body>
</html>
<style is:global>
	@import url('https://fonts.googleapis.com/css2?family=Montserrat:ital,wght@0,100..900;1,100..900&family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&display=swap');

	:root {
		font-family: "Montserrat", sans-serif;
	}

	html, body {
		scroll-behavior: smooth;
	}
	.snap-start {
		@apply transition-opacity duration-500;
	}
</style>
