---
interface Props {
	image?: string;
}

const { description, image: imageConfig } = config;
const {  image = imageConfig } = Astro.props;

import config from "@/config/config";
import Header from "./partials/Header.astro";

const { pathname } = Astro.url;
const url = Astro.url.toString().replace("http://", "https://");
const canonicalURL = new URL(pathname, url);
const isContactPage = pathname === "/contact" || pathname === "/contact/";
---

<!doctype html>
<html lang="es" class="scroll-smooth">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width" />
		<link rel="icon" type="image/x-icon" href="/logos/logo.webp" />
		<title>{config.title}</title>

		<meta charset="UTF-8" />
		<meta name="description" content={description} />
		<link rel="canonical" href={canonicalURL} />
		<meta
			name="viewport"
			content="width=device-width,initial-scale=1,shrink-to-fit=no"
		/>
		<meta http-equiv="x-ua-compatible" content="ie=edge" />

		<meta name="theme-color" content={config.theme_color} />
		<meta name="keywords" content={config.keywords} />
		<meta name="twitter:card" content="summary_large_image" />
		<meta name="twitter:site" content={config.author} />
		<meta name="twitter:creator" content={config.author} />
		<meta name="twitter:title" content={config.title} />
		<meta name="twitter:description" content={description} />
		<meta name="twitter:image" content={new URL(image, url)} />

		<meta name="og:image" content={new URL(image, url)} />
		<meta name="og:title" content={config.title} />
		<meta name="og:description" content={description} />
		<meta name="og:url" content={url} />
		<meta name="og:site_name" content={config.site_name} />
		<meta name="og:type" content="website" />
		<meta name="og:locale" content="es_ES" />

		<meta itemprop="image" content={new URL(image, url)} />

		<meta name="robots" content="index, follow" />
		<meta name="googlebot" content="index, follow" />

		<meta name="msapplication-config" content="/browserconfig.xml" />

		<link rel="manifest" href="/manifest.webmanifest" />

		<link rel="preconnect" href="https://fonts.googleapis.com" />
		<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
		<link
			href="https://fonts.googleapis.com/css2?family=Montserrat:ital,wght@0,100..900;1,100..900&family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&display=swap"
			rel="stylesheet"
		/>
		{config.IS_PRODUCTION && <></>}
		<style is:global>
			/* Fuentes para toda la página */
			body {
				font-family: 'Montserrat', sans-serif;
			}
			
			h1, h2, h3, h4, h5, h6 {
				font-family: 'Montserrat', sans-serif;
				font-weight: 300;
				line-height: 1.2;
			}
			
			b, strong {
				font-weight: 700;
			}
			
			/* Animación para letras individuales */
			.split-text .char {
				display: inline-block;
				opacity: 0;
				transform: translateY(30px);
				transition: opacity 0.3s ease, transform 0.3s ease;
			}
			
			.split-text .char.visible {
				opacity: 1;
				transform: translateY(0);
			}
			
			/* Animación para contenedores */
			.fade-in {
				opacity: 0;
				transform: translateY(20px);
				transition: opacity 0.6s ease, transform 0.6s ease;
			}
			
			.fade-in.visible {
				opacity: 1;
				transform: translateY(0);
			}
			
			/* Estilo para ocultar los valores originales mientras se animan */
			.count-number-original {
				display: none;
			}
		</style>
	</head>
	<body class="max-w-full overflow-x-hidden font-['Montserrat']">
		<Header />
		<main class="flex flex-col items-stretch justify-between">
			<slot />
		</main>
		<script define:vars={{ isContactPage }}>
			if (!isContactPage) {
				let currentSection = 0;
				let isScrolling = false;
				let lastScrollTime = 0;
				
				function isMobile() {
					return window.innerWidth < 1024;
				}
				
				const sections = document.querySelectorAll('section');
				
				function scrollToSection(index) {
					if (isScrolling) return;
					
					// Asegurarse de que el índice está dentro del rango
					if (index < 0) index = 0;
					if (index >= sections.length) index = sections.length - 1;
					
					isScrolling = true;
					currentSection = index;
					
					if (!sections[index]) {
						isScrolling = false;
						return;
					}
					
					sections[index].scrollIntoView({ behavior: 'smooth' });
					
					// Tiempo suficiente para la animación, pero no demasiado largo
					setTimeout(() => {
						isScrolling = false;
					}, 600);
				}

				const updateSection = () => {
					if (!isMobile()) {
						// Reiniciar a la primera sección al cargar
						currentSection = 0;
						
						// Remover el event listener anterior si existe
						window.removeEventListener('wheel', handleWheel);
						
						// Añadir el event listener con la nueva implementación
						window.addEventListener('wheel', handleWheel, { passive: false });
					} else {
						// En dispositivos móviles, remover el listener
						window.removeEventListener('wheel', handleWheel);
					}
				};
				
				function handleWheel(e) {
					e.preventDefault();
					
					if (isScrolling) return;
					
					// Comprobar si ha pasado suficiente tiempo desde el último scroll
					const now = Date.now();
					if (now - lastScrollTime < 50) return; // Pequeño debounce para evitar scrolls accidentales
					
					lastScrollTime = now;
					
					// Detectar dirección inmediatamente
					const direction = e.deltaY > 0 ? 1 : -1;
					
					// Moverse sólo si hay una sección disponible en esa dirección
					if ((direction > 0 && currentSection < sections.length - 1) || 
						(direction < 0 && currentSection > 0)) {
						scrollToSection(currentSection + direction);
					}
				}
				
				document.addEventListener('DOMContentLoaded', () => {
					// Inicialmente, desplazarse a la primera sección
					if (!isMobile()) {
						sections[0].scrollIntoView({ behavior: 'auto' });
					}
					
					updateSection();
						
					window.addEventListener('resize', () => {
						updateSection();
					});
					
					// Habilitar navegación con teclado
					document.addEventListener('keydown', (e) => {
						if (isScrolling || isMobile()) return;
						
						if (e.key === 'ArrowDown' || e.key === 'PageDown') {
							if (currentSection < sections.length - 1) {
								scrollToSection(currentSection + 1);
							}
						} else if (e.key === 'ArrowUp' || e.key === 'PageUp') {
							if (currentSection > 0) {
								scrollToSection(currentSection - 1);
							}
						} else if (e.key === 'Home') {
							scrollToSection(0);
						} else if (e.key === 'End') {
							scrollToSection(sections.length - 1);
						}
					});
				});
			}
		</script>
		<script>
			import SplitType from 'split-type'
			document.addEventListener('DOMContentLoaded', () => {
				// Configurar animación de texto letra por letra
				document.querySelectorAll('.split-text').forEach(element => {
					if (element instanceof HTMLElement) {
						new SplitType(element, { types: 'chars' });
					}
				});
				
				// Crear observer para animar elementos al verlos
				const observer = new IntersectionObserver(entries => {
					entries.forEach(entry => {
						if (entry.isIntersecting) {
							// Si es un título con animación letra por letra
							if (entry.target.classList.contains('split-text')) {
								const chars = entry.target.querySelectorAll('.char');
								chars.forEach((char, index) => {
									setTimeout(() => {
										char.classList.add('visible');
									}, 30 * index);
								});
							} 
							// Si es un contenedor con fade
							else if (entry.target.classList.contains('fade-in')) {
								entry.target.classList.add('visible');
							}
							
							// Dejar de observar después de animar
							observer.unobserve(entry.target);
						}
					});
				}, {
					threshold: 0.2
				});
				
				// Observar todos los elementos que necesitan animación
				document.querySelectorAll('.split-text, .fade-in').forEach(el => {
					observer.observe(el);
				});
			});
		</script>
		<script is:inline>
			// Animación de contadores de manera no invasiva
			const counterSection = document.querySelector('section:has(b[class*="font-extrabold"])');
			if (counterSection) {
				const numberElements = counterSection.querySelectorAll('b[class*="font-extrabold"]');
				
				// Crear observador
				const observer = new IntersectionObserver((entries) => {
					if (entries[0].isIntersecting) {
						// Animar cada número
						numberElements.forEach(el => {
							// Guardar texto original
							const originalText = el.textContent;
							
							// Extraer el número y separar prefijo/sufijo
							let prefixMatch = originalText.match(/^[^\d]*/);
							let prefix = prefixMatch ? prefixMatch[0] : '';
							
							let numberStr = originalText.replace(prefix, '');
							let suffixMatch = numberStr.match(/[^\d.,]+$/);
							let suffix = suffixMatch ? suffixMatch[0] : '';
							
							// Obtener solo el número limpio
							let cleanNumber = numberStr.replace(suffix, '').replace(/,/g, '');
							let targetNumber = parseFloat(cleanNumber);
							
							// Valores para la animación
							let currentNumber = 0;
							const duration = 2000;
							const steps = 60;
							const increment = targetNumber / steps;
							const interval = duration / steps;
							
							// Función de conteo
							function count() {
								currentNumber += increment;
								if (currentNumber >= targetNumber) {
									el.textContent = originalText; // Restaurar texto original al finalizar
									return;
								}
								
								// Formatear número
								let formattedNumber;
								if (targetNumber > 999) {
									formattedNumber = Math.floor(currentNumber).toLocaleString();
								} else {
									formattedNumber = Math.floor(currentNumber);
								}
								
								// Combinar prefijo, número formateado y sufijo
								el.textContent = prefix + formattedNumber + suffix;
								setTimeout(count, interval);
							}
							
							// Iniciar conteo
							count();
						});
						
						observer.disconnect();
					}
				}, { threshold: 0.2 });
				
				observer.observe(counterSection);
			}
		</script>
	</body>
</html>
<style is:global>
	@import url('https://fonts.googleapis.com/css2?family=Montserrat:ital,wght@0,100..900;1,100..900&family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&display=swap');

	:root {
		font-family: "Montserrat", sans-serif;
	}

	html, body {
		scroll-behavior: smooth;
	}
	.snap-start {
		@apply transition-opacity duration-500;
	}
</style>
